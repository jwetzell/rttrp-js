const { deepEqual, throws } = require('assert');
const { describe, it } = require('node:test');
const { Encoders } = require('../');

const goodTests = [
  {
    description: 'Centroid Position',
    expected: new Uint8Array([
      0x02, 0x00, 0x1d, 0x00, 0x10, 0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x40, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ]),
    bytes: () => {
      return Encoders.CentroidPosition(16, 1, 2, 3);
    },
  },
  {
    description: 'Tracked Point Position',
    expected: new Uint8Array([
      0x06, 0x00, 0x1e, 0x00, 0x10, 0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x40, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    ]),
    bytes: () => {
      return Encoders.TrackedPointPosition(16, 1, 2, 3, 1);
    },
  },
  {
    description: 'Orientation (Quaternion)',
    expected: new Uint8Array([
      0x03, 0x00, 37, 0x00, 0x10, 0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x40, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ]),
    bytes: () => {
      return Encoders.OrientationQuaternion(16, 1, 2, 3, 4);
    },
  },
  {
    description: 'Orientation (Euler)',
    expected: new Uint8Array([
      0x04, 0x00, 31, 0x00, 0x10, 0x01, 0x23, 0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x40, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ]),
    bytes: () => {
      return Encoders.OrientationEuler(16, 0x0123, 1, 2, 3);
    },
  },
  {
    description: 'Centroid Acceleration and Velocity',
    expected: new Uint8Array([
      0x20, 0x00, 51, 0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x40, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x80, 0x00, 0x00, 0x40, 0xa0, 0x00, 0x00, 0x40, 0xc0, 0x00,
      0x00, 0x40, 0xe0, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 0x41, 0x10, 0x00, 0x00,
    ]),
    bytes: () => {
      return Encoders.CentroidAccelVelocity(1, 2, 3, 4, 5, 6, 7, 8, 9);
    },
  },
  {
    description: 'Tracked Point Acceleration and Velocity',
    expected: new Uint8Array([
      0x21, 0x00, 52, 0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x40, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x80, 0x00, 0x00, 0x40, 0xa0, 0x00, 0x00, 0x40, 0xc0, 0x00,
      0x00, 0x40, 0xe0, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 0x41, 0x10, 0x00, 0x00, 0x01,
    ]),
    bytes: () => {
      return Encoders.TrackedPointAccelVelocity(1, 2, 3, 4, 5, 6, 7, 8, 9, 1);
    },
  },
  {
    description: 'Zone Collision Detection',
    expected: new Uint8Array([
      0x22, 0x00, 0x14, 0x02, 0x08, 0x06, 0x7a, 0x6f, 0x6e, 0x65, 0x20, 0x31, 0x08, 0x06, 0x7a, 0x6f, 0x6e, 0x65, 0x20,
      0x32,
    ]),
    bytes: () => {
      return Encoders.ZoneCollisionDetection([Encoders.ZoneObject('zone 1'), Encoders.ZoneObject('zone 2')]);
    },
  },
  {
    description: 'Zone Object',
    expected: new Uint8Array([0x08, 0x06, 0x7a, 0x6f, 0x6e, 0x65, 0x20, 0x31]),
    bytes: () => {
      return Encoders.ZoneObject('zone 1');
    },
  },
  {
    description: 'Trackable (with Timestamp) + Centroid Position Module',
    expected: new Uint8Array([
      81, 0, 42, 4, 84, 101, 115, 116, 103, 213, 152, 27, 1, 2, 0, 29, 0, 100, 63, 240, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0,
      0, 0, 0, 0, 64, 8, 0, 0, 0, 0, 0, 0,
    ]),
    bytes: () => {
      return Encoders.Trackable('Test', [Encoders.CentroidPosition(100, 1, 2, 3)], 1742051355);
    },
  },
  {
    description: 'Trackable (with Timestamp) + Tracked Point Position Module',
    expected: new Uint8Array([
      81, 0, 43, 4, 84, 101, 115, 116, 103, 213, 152, 27, 1, 6, 0, 30, 0, 100, 63, 240, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0,
      0, 0, 0, 0, 64, 8, 0, 0, 0, 0, 0, 0, 1,
    ]),
    bytes: () => {
      return Encoders.Trackable('Test', [Encoders.TrackedPointPosition(100, 1, 2, 3, 1)], 1742051355);
    },
  },
  {
    description: 'RTTrPM + Empty Trackable',
    expected: new Uint8Array([
      65, 84, 67, 52, 0, 2, 0, 0, 0, 1, 0, 0, 27, 18, 52, 86, 120, 1, 1, 0, 9, 4, 84, 101, 115, 116, 0,
    ]),
    bytes: () => {
      return Encoders.RTTrPM(1, 0x12345678, [Encoders.Trackable('Test', [])]);
    },
  },
];

describe('RTTrPM Message Encoding', () => {
  goodTests.forEach((messageTest) => {
    it(messageTest.description, () => {
      const actual = messageTest.bytes();
      deepEqual(actual, messageTest.expected);
    });
  });
});

//TODO(jwetzell): add tests that handle errors
const badTests = [];

describe('RTTrPM Message Encoding Throws', () => {
  badTests.forEach((messageTest) => {
    it(messageTest.description, () => {
      messageTest.bytes();
      throws(() => {}, messageTest.throwsMessage);
    });
  });
});
